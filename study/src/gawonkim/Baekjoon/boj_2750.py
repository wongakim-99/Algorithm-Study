# 버블정렬하기
N = int(input())
M = []

for i in range(N):
    M.append(int(input()))

# Bubble sort
for i in range(len(M)):
    for j in range(len(M)):
        if M[i] < M[j]:
            M[i], M[j] = M[j], M[i]

for n in M:
    print(n)

'''
버블정렬(Bubble sort) 알고리즘

서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
● 인접한 2개의 원소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환

버블정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를....
이런식으로 (n-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬

1회전을 수행하고 나면 가장 큰 원소가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외되고, 
2회전에서는 두 번째로 큰 원소까지는 정렬에서 제외된다.
이런식으로 정렬을 1회전 수행할 때마다 제외되는 데이터가 하나씩 늘어난다.

ex) 7   4   5   1   3 이 저장되어 있다고 가정하고 자료를 오름차순으로 정렬

7부터 스타또!
1회전)
7   4   5   1   3
4   7   5   1   3
4   5   7   1   3
4   5   1   7   3
4   5   1   3   7 <- 1회전 결과


4부터 스타또
2회전)
4   5   1   3   7
4   1   5   3   7
4   1   3   5   7 <- 2회전 결과
(뒤에 실행은 같은 결과이므로 중략)


다시 4부터 스따트
3회전)
4   1   3   5   7
1   4   3   5   7
1   3   4   5   7 <- 3회전 결과
(뒤에 실행은 같은 결과이므로 중략)

요런식으로 버블정렬이 실행된다.

1회전
첫 번째 자료 7을 두 번째 자료 4와 비교하여 교환하고, 두 번째의 7과 세 번째의 5를 비교하여 교환하고, 
세 번째의 7과 네 번째의 1을 비교하여 교환하고, 네 번째의 7과 다섯 번째의 3을 비교하여 교환한다. 
이 과정에서 자료를 네 번 비교한다. 
그리고 가장 큰 자료가 맨 끝으로 이동하므로 다음 회전에서는 맨 끝에 있는 자료는 비교할 필요가 없다.

2회전
첫 번째의 4을 두 번째 5와 비교하여 교환하지 않고, 두 번째의 5와 세 번째의 1을 비교하여 교환하고, 
세 번째의 5와 네 번째의 3을 비교하여 교환한다. 이 과정에서 자료를 세 번 비교한다. 
비교한 자료 중 가장 큰 자료가 끝에서 두 번째에 놓인다.

3회전
첫 번째의 4를 두 번째 1과 비교하여 교환하고, 두 번째의 4와 세 번째의 3을 비교하여 교환한다.
이 과정에서 자료를 두 번 비교한다. 비교한 자료 중 가장 큰 자료가 끝에서 세 번째에 놓인다.

4회전
첫 번째의 1과 두 번째의 3을 비교하여 교환하지 않는다.


버블정렬의 시간복잡도
● 비교 횟수
최상, 평균, 최악 모두 일정
n-1, n-2, n-3, --- , 2, 1번 = n(n-1)/2

입력 자료가 역순으로 정렬되어 있는 최악의 경우, 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 
(비교 횟수 * 3) 번 = 3n(n-1)/2

따라서 시간복잡도는 최악, 최선, 평균의 경우 O(n^2) 로 일정하다



+++여담
버블정렬의 장점
-구현이 간단함

버블정렬의 단점
-장점이외의 모든것ㅋㅋㅋㅋ

-하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
-특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
일반적으로 원소의 교환 작업(SWAP)이 원소의 이동작업보다 더 복잡...
거의 안쓰임
'''


# 선택정렬
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]

# 입력 받기
N = int(input())
numbers = [int(input()) for _ in range(N)]

# 선택 정렬 수행
selection_sort(numbers)

# 결과 출력
for num in numbers:
    print(num)


'''
선택정렬(Selection sort)

각 루프마다 
-최대 원소를 찾는다
-최대 원소와 맨 오른쪽 원소를 교환한다
-맨 오른쪽 원소를 제외한다

ex) 12 70 30 20 55 25   <- 이 원소들을 선택정렬로 정렬한다고 해보자
1st) 전체원소 중 최대 값을 찾아서 맨 오른쪽으로 보낸다.
결과 -> 12 25 30 20 55 | 70

2dn) 첫 번째에서 찾은 최대값을 제외하고 남은 n-1개의 원소 중 최대값을 찾아서 다시 맨 오른쪽으로 보낸다
12 25 30 20 | 55 70
.
.
.
위와 같은 과정을 원소가 1개 남을때까지 반복

(1   3   4   8   7   9   ....    13   46) <- 이런식으로 원소가 n개 있다고 가정
첫번째 루프에서 최대값을 찾은 후 n-1개의 원소를 돔
두번째 루프에서 최대값을 찾은 후 n-2개의 원소를 돔
세번째 루프에서 최대값을 찾은 후 n-3개의 원소를 돔
...(원소가 남은 1개가 될 때까지 반복)

프로그램을 위와같이 실행하면 프로그램의 실행 횟수는
1 + 2 + 3 + 4 + 5 + ... + (n-2) + (n-1) 번이 될 것이다.

다 더하면 ((n-1) x n) / 2 = O(n^2)
따라서 시간복잡도는 O(n^2)라는 결과가 나오게 된다.

시간복잡도 관련해서 조금 더 부가적으로 설명하자면
비교횟수 
● 두 개의 for루프의 실행 횟수
● 외부루프 : (n-1)번
● 내부 루프(최대값 찾기) : n-1, n-2, ... , 2, 1 번

교환횟수
● 외부 루프의 실행횟수와 동일. 즉, 상수시간작업
● 한 번 교환하기 위해 **3번의 이동(SWAP함수) -> 3(n-1)번

**-> 변수1, 변수2, 임시저장변수
임시저장변수 = 변수1
변수1 = 변수2
변수2 = 임시저장변수 (이런식의 스왑함수)

https://github.com/wongakim-99/Algorithm-Study/blob/main/study/src/gawonkim/Baekjoon/boj_10813.py
위의 링크의 코드중 10~12라인 잘 참고할것!

선택정렬 같은 경우는 최악의 경우, 최선의 경우, 평균의 경우 모든 경우의 수가 똑같이 일을 하기 때문에
시간복잡도는 O(n^2) 가 된다.





참고자료 : https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html
'''