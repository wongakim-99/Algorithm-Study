def quick_select(arr, k):
    """
    arr에서 k번째로 작은 값을 찾는 함수
    """
    pivot = arr[0]  # 첫 번째 요소를 pivot으로 선택
    lower = [x for x in arr[1:] if x <= pivot]  # pivot보다 작은 값들의 배열
    upper = [x for x in arr[1:] if x > pivot]   # pivot보다 큰 값들의 배열

    if len(lower) == k - 1:
        return pivot
    elif len(lower) >= k:
        return quick_select(lower, k)
    else:
        return quick_select(upper, k - len(lower) - 1)

# 입력 처리
N, k = map(int, input().split())
scores = list(map(int, input().split()))

# 퀵 정렬을 사용하여 상을 받는 커트라인 찾기
cutoff = quick_select(scores, N - k + 1)
print(cutoff)


# 퀵 정렬 -> 평균적으로 가장 좋은 성능을 가진 algorithm
'''
퀵 정렬은 평균적으로 가장 좋은 성능을 가져 자주 사용하는 정렬 알고리즘이다.

우선 밑에 그림을 기준으로 설명을 해보겠다.

>정렬할 배열이 주어진다. 맨 뒤의 15를 기준원소로 삼는다
31  8   48  73  11  3   20  29  65  (15)

기준(15)보다 작은 수는 기준의 왼쪽에, 나머지는 기준의 오른쪽에 오도록 재배치한다
(a) -> 8   11  3   (15)    31  48  20  29  65  73

기준원소(15)왼쪽과 오른쪽을 독립적으로 정렬한다(정렬 완료)
(b) -> 3   8   11   (15)  20  29  31  48  65  73   


a에서는 기준원소인 15를 중심으로 이보다 작은 원소들은 15의 왼쪽에, 나머지 원소들은 15의 오른쪽에 재배치한다.
이 결과 8,11,3은 15의 왼쪽에, 31,48,20,29,65,73은 15의 오른쪽에 오도록 재배치되었다

b에서 왼쪽의 원소 3개와 오른쪽의 원소6개를 각각 독립적으로 정렬한다. 왼쪽 3개의 원소를 정렬할 때 15의 자리는 
영향을 받지 않는다. 오른쪽 6개의 원소를 정렬할 때도 역시 15의 자리는 영향을 받지 않는다.
즉! 기준원소 15는 왼쪽과 오른쪽의 정렬을 시작하기 전에 이미 제자리를 찾은 것이다.
왼쪽과 오른쪽의 정렬이 끝나는 순간 전체 배열의 정렬이 끝난다.
왼쪽과 오른쪽의 정렬을 위해서는 다시 퀵 정렬을 사용하면 된다. 즉, 퀵 정렬을 재귀적으로 수행한다.

정리)

1. 기준이 되는 데이터를 피벗(Pivot)으로 설정한다.
 : 대표적인 분할 방식인 호어 분할(Hoare Partition)방식을 기준으로 진행
 (※피벗을 어떻게 설정하고 리스트를 분할하는가에 따라서 다양한 방식의 퀵정렬이 존재) -> 우리는 피벗을 맨 뒤의 값으로 약속

2. 피벗을 설정 한 후, 피벗을 기준으로 왼쪽에서는 피벗보다 큰 데이터를 찾고, 오른쪽에서는 피벗보다 작은 데이터를 찾아서
서로 위치를 교환한다.

3. 1,2 의 과정을 반복한다.


퀵 정렬 알고리즘 pseudo code(의사코드)
quickSort(A[],p,r)  //A[p....r]을 정렬한다
{
    if(p<r) then {
        q <- partition(A,p,r);  //분할
        quickSort(A,p,q-1);     //왼쪽 부분 배열 정렬
        quickSort(A,q+1,r);     //오른쪽 부분 배열 정렬
    }
}

partition(A[],p,r)  //분할
{
    x <- A[r];  //기준원소
    i <- p-1;   //i는 1구역의 끝지점
    for j <- p to r-1   //j는 3구역의 시작 지점
        if (A[j]<= x) then A[++i] <-> A[j];
        //의미는 i값 증가 후 A[i] <-> A[j] 교환
    A[i+1] <-> A[r];
    return i+1;
}

'''
