def quick_select(arr, k):
    """
    arr에서 k번째로 작은 값을 찾는 함수
    """
    pivot = arr[0]  # 첫 번째 요소를 pivot으로 선택
    lower = [x for x in arr[1:] if x <= pivot]  # pivot보다 작은 값들의 배열
    upper = [x for x in arr[1:] if x > pivot]   # pivot보다 큰 값들의 배열

    if len(lower) == k - 1:
        return pivot
    elif len(lower) >= k:
        return quick_select(lower, k)
    else:
        return quick_select(upper, k - len(lower) - 1)

# 입력 처리
N, k = map(int, input().split())
scores = list(map(int, input().split()))

# 퀵 정렬을 사용하여 상을 받는 커트라인 찾기
cutoff = quick_select(scores, N - k + 1)
print(cutoff)


# 퀵 정렬 -> 평균적으로 가장 좋은 성능을 가진 algorithm
'''
퀵 정렬은 평균적으로 가장 좋은 성능을 가져 자주 사용하는 정렬 알고리즘이다.

우선 밑에 그림을 기준으로 설명을 해보겠다.

>정렬할 배열이 주어진다. 맨 뒤의 15를 기준원소로 삼는다
31  8   48  73  11  3   20  29  65  (15)

기준(15)보다 작은 수는 기준의 왼쪽에, 나머지는 기준의 오른쪽에 오도록 재배치한다
(a) -> 8   11  3   (15)    31  48  20  29  65  73

기준원소(15)왼쪽과 오른쪽을 독립적으로 정렬한다(정렬 완료)
(b) -> 3   8   11   (15)  20  29  31  48  65  73   


a에서는 기준원소인 15를 중심으로 이보다 작은 원소들은 15의 왼쪽에, 나머지 원소들은 15의 오른쪽에 재배치한다.
이 결과 8,11,3은 15의 왼쪽에, 31,48,20,29,65,73은 15의 오른쪽에 오도록 재배치되었다

b에서 왼쪽의 원소 3개와 오른쪽의 원소6개를 각각 독립적으로 정렬한다. 왼쪽 3개의 원소를 정렬할 때 15의 자리는 
영향을 받지 않는다. 오른쪽 6개의 원소를 정렬할 때도 역시 15의 자리는 영향을 받지 않는다.
즉! 기준원소 15는 왼쪽과 오른쪽의 정렬을 시작하기 전에 이미 제자리를 찾은 것이다.
왼쪽과 오른쪽의 정렬이 끝나는 순간 전체 배열의 정렬이 끝난다.
왼쪽과 오른쪽의 정렬을 위해서는 다시 퀵 정렬을 사용하면 된다. 즉, 퀵 정렬을 재귀적으로 수행한다.

정리)

1. 기준이 되는 데이터를 피벗(Pivot)으로 설정한다.
 : 대표적인 분할 방식인 호어 분할(Hoare Partition)방식을 기준으로 진행
 (※피벗을 어떻게 설정하고 리스트를 분할하는가에 따라서 다양한 방식의 퀵정렬이 존재) -> 우리는 피벗을 맨 뒤의 값으로 약속

2. 피벗을 설정 한 후, 피벗을 기준으로 왼쪽에서는 피벗보다 큰 데이터를 찾고, 오른쪽에서는 피벗보다 작은 데이터를 찾아서
서로 위치를 교환한다.

3. 1,2 의 과정을 반복한다.


퀵 정렬 알고리즘 pseudo code(의사코드)
quickSort(A[],p,r)  //A[p....r]을 정렬한다
{
    if(p<r) then {
        q <- partition(A,p,r);  //분할
        quickSort(A,p,q-1);     //왼쪽 부분 배열 정렬
        quickSort(A,q+1,r);     //오른쪽 부분 배열 정렬
    }
}

partition(A[],p,r)  //분할
{
    x <- A[r];  //기준원소
    i <- p-1;   //i는 1구역의 끝지점
    for j <- p to r-1   //j는 3구역의 시작 지점
        if (A[j]<= x) then A[++i] <-> A[j];
        //의미는 i값 증가 후 A[i] <-> A[j] 교환
    A[i+1] <-> A[r];
    return i+1;
}


(image)디렉토리에 사진 참고
사진에서 보았던 분할 알고리즘에서 발견할 수 있는 몇 가지 성질을 정리하면 다음과 같다.

1. for 루프가 한 바퀴 돌 때마다 3구역이 한칸씩 줄어든다.
2. for 루프가 한 바퀴 돌 때마다 1구역 또는 2구역 중 하나가 한 칸 늘어난다.
3. 2구역이 늘어날 때는 j만 1 증가한다. for루프가 한 바퀴 돌 때마다 j는 1 증가하므로 2구역을 늘리기 위해서는
아무 일도 할 필요가 없다.
4. 1구역이 늘어날 때는 i와j가 동시에 1 증가한다.





******************************퀵 정렬의 수행시간 분석******************************

퀵 정렬의 수행 시간을 분석해보자. 우선 분할은 배열을 왼쪽부터 끝까지 한 번 훓어나가는 작업이므로
O(n)의 시간이 든다. 퀵 정렬의 수행에서 가장 이상적인 경우는 분할이 항상 반반씩 균등하게 될 때다.
이때는 시간이 다음과 같이 되어 병합 정렬과 같은 모양이므로 O(nlogn)이 된다.

T(n) = 2T(n/2) + O(n)

최악의 경우는 계속해서 한쪽은 하나도 없고 다른 쪽에 다 몰리도록 분할이 되는 경우다.
이때는 시간이 다음과 같이 되어 O(n^2)이 된다.

T(n) = T(n-1) + O(n)

한쪽이 완전히 비거나 이에 근접한 상태가 반복되면 이런 비효율적인 시간이 나온다.
그렇지만 이런 불운한 경우가 반복될 확률은 아주 희박하다. 최선의 경우와 최악의 경우 같은 경우는 이 정도로 충분





******************************평균의 경우 퀵 정렬의 수행 시간 분석******************************

퀵 정렬의 수행 시간은 분할이 얼마나 균형잡히게 잘 되느냐에 달려 있다. 평균 수행 시간은 분할했을 때
모든 가능한 경우를 평균내면 된다. 기준원소를 중심으로 n개의 원소를 분할했을 때 기준원소가 n개의 원소 중 작은
순서로 몇 등인지에 따라 분할의 모양이 결정된다.
기준원소가 1등이면 1구역과 2구역의 크기는 0:n-1 이 된다. 2등이면 1:n-2가 된다. 기준원소가 i등이면 1구역과 
2구역의 크기는 i-1:n-i 가 된다. 이 경우의 수행 시간은 다음과 같이 나타낼 수 있다.

T(n) = T(i-1) + T(n-i) + O(n)

여기서 T(i-1) 과 T(n-i)는 재귀호출 비용이고 O(n)은 분할 비용이다. 기준원소는 동일한 확률로 1등부터 n등 중의 
하나가 되므로 이들을 평균하면 다음과 같이 된다.

file:///C:/Users/kgw19/Downloads/CodeCogsEqn.svg

이것을 계산하면 T(n) = O(nlogn)이 된다.
'''
