# 대표값2

'''
문제해결 로직은 5개의 숫자를 정렬하고 그 중에서 중앙값 찾고 평균구하면 단순한 로직임

그 로직중 정렬에서 "삽입정렬"(Insert Sort)을 사용해보도록 하겠음
'''

array = []
for i in range(5):
    array.append(int(input()))

# 삽입정렬
for i in range(1, len(array)):
    for j in range(i , 0, -1):
        print(array)    # 이거는 삽입정렬되는 과정 확인해보라고 넣은것
        if array[j] < array[j-1]:
            array[j], array[j-1] = array[j-1], array[j]
        else:
            break

print(int(sum(array)/5))
print(array[2])

'''
삽입정렬(insertion sort) 알고리즘의 구체적인 개념

- 삽입정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여
삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여
정렬하는 알고리즘이다.

- 즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료,
네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다.
자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.

배열에 10,40,30,60,30 이 저장되어 있다고 가정해보자

1회전)
10  40  30  60  30 (key : 40) -> 두 번째 자료
1. 첫 번째 값 10과 비교 -> 40이 10보다 더 크므로 그대로 둔다
*****(10  40  30  60  30) -> 1회전 결과


2회전)
10  40  30  60  30 (key : 30) -> 세 번째 자료
1. 두 번째 값 40과 비교 -> 30이 40보다 더 작으므로 40을 한 칸 뒤로 이동
10  x  ->  40  60  30
    30

2. 첫 번째 값 30과 비교 -> 10은 그대로 30을 두 번째 자리에 넣는다.
******(10  30  40  60  30) -> 2회전 결과


3회전)
10  30  40  60  30 (key : 60) -> 네 번째 자료
1. 세 번째 값 40과 비교 -> 60이 40보다 크므로 그대로 놔둔다.
마찬가지로 그 뒤에 값들도 60보다 작으므로 그대로 놔둠
******(10  30  40  60  30) -> 3회전 결과


4회전)
10  30  40  60  30 (key : 30) -> 다섯번째 자료
1. 4번째 값 60과 비교 -> 30이 60보다 작으므로 60을 한 칸 뒤로 이동
10  30  40  x -> 60
            30

2. 3번째 값 40과 비교 -> 30이 40보다 작으므로 40을 한 칸 뒤로 이동
10  30  x -> 40  60
        30

3. 2번째 갑 30과 비교 -> 30은 그대로 놔두고, 30을 세 번째 자리에 넣는다
******(10  30  30  40  60)

정렬완성

삽입정렬(insertion sort)알고리즘의 특징

장점
● 안정한 정렬 방법
● 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
● 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.

단점
● 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
● 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.
'''